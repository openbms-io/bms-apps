# Story 2.11: Advanced Tab - Triple Inspector

**Epic:** Epic 2 - BuildingMOTIF API Integration
**Phase:** Phase 2 - BuildingMOTIF SDK Integration
**Status:** drafted
**Created:** 2025-11-18
**Complexity:** 4 (High)
**Estimated Hours:** 14-17 hours

---

## User Story

**As a** backend developer and frontend developer,
**I want** to expose the complete RDF graph for each equipment mapping via API and visualize it in a React Flow graph,
**So that** users can see all 20-50+ triples generated by BuildingMOTIF's template.fill(), understand ASHRAE 223P semantic relationships, and debug SHACL validation failures effectively.

---

## Context

### Problem Statement

**Current State:**

When users create an ASHRAE 223P semantic mapping in the Designer UI, they provide only **5 fields**:

```typescript
{
  equipmentTypeId: "vav-reheat",
  deviceTypeId: "sensor",
  propertyId: "air-temperature",
  physicalSpaceId: "room-101" | null,
  domainSpaceIds: ["hvac-zone-1"] | null
}
```

**Hidden Complexity:**

Behind the scenes, BuildingMOTIF's `template.fill()` generates **20-50+ RDF triples** per mapping, including:

- Type classifications (rdf:type)
- Quantity kinds and units (qudt:hasQuantityKind, qudt:hasUnit)
- Medium and aspect properties (s223:hasMedium, s223:hasAspect)
- Connection topology (s223:contains, s223:connectedTo, s223:cnx)
- Observation locations (s223:hasObservationLocation)
- Space relationships (s223:locatedIn, s223:hasDomain)
- External references (bacnet:device-identifier, bacnet:object-identifier)

**Result:** **95% of the semantic graph is invisible** to users.

### Why This Matters

1. **Transparency:** Users can't verify what semantic assertions are being made
2. **Debugging:** Hard to troubleshoot SHACL validation failures without seeing full graph
3. **Learning:** Users can't learn ASHRAE 223P patterns from examples
4. **Trust:** "Black box" semantic tagging reduces confidence

### Solution

Expose the complete RDF graph for each equipment mapping via:

- **New API endpoint:** `GET /api/v1/223p/triples?equipmentUrn={urn}`
- **Enhanced mappings response:** Include URN metadata for each mapping field
- **UI:** React Flow graph visualization in modal overlay
- **Format:** Graph-optimized JSON (nodes/edges) for easy visualization

### Architecture Decisions (All Resolved)

All architecture decisions resolved as of 2025-11-18. See mini-spec for full details:
`docs/feature-development/ashrae-223p-ai-g36-integration/mini-specs/2-11-triple-inspector-architecture.md`

| #   | Decision Area     | Resolution                                           |
| --- | ----------------- | ---------------------------------------------------- |
| 1   | UI Display Format | React Flow graph visualization                       |
| 2   | Display Method    | Modal overlay (not separate route)                   |
| 3   | Data Transfer     | New GET /api/v1/223p/triples endpoint                |
| 4   | Performance       | Single equipment focus (20-50 triples per equipment) |
| 5   | Serialization     | Graph-optimized JSON (nodes/edges)                   |
| 6   | Grouping          | No backend pre-grouping (frontend filters)           |
| 7   | Versioning        | No versioning concern (still in development)         |

---

## Acceptance Criteria

### Backend API

#### AC #1: âœ… Enhanced GET /api/v1/223p/mappings returns URN metadata

**Current response:**

```json
{
  "projectId": "...",
  "mappings": {
    "device,599:analog-input,3": {
      "equipmentTypeId": "vav-reheat",
      "deviceTypeId": "sensor",
      "propertyId": "air-temperature",
      "physicalSpaceId": null,
      "domainSpaceIds": null
    }
  }
}
```

**New response:**

```json
{
  "projectId": "...",
  "mappings": {
    "device,599:analog-input,3": {
      "equipmentType": {
        "templateId": "vav-reheat",
        "urn": "urn:equipment:device-599-ai-3"
      },
      "deviceType": {
        "templateId": "sensor",
        "urn": "urn:device:sensor-device-599-ai-3"
      },
      "property": {
        "templateId": "air-temperature",
        "urn": "urn:property:air-temp-device-599-ai-3"
      },
      "physicalSpace": null,
      "domainSpaces": null
    }
  }
}
```

**Breaking change:** Yes, but acceptable (still in development)

- [ ] Mappings response includes URN for each field
- [ ] URN format: `urn:{type}:{identifier}`
- [ ] All fields updated: equipmentType, deviceType, property, physicalSpace, domainSpaces
- [ ] Existing mappings tests updated for new response format
- [ ] TypeScript client regenerated with new types

#### AC #2: âœ… New GET /api/v1/223p/triples endpoint returns graph structure

**Endpoint:** `GET /api/v1/223p/triples?equipmentUrn={urn}`

**Response structure:**

```typescript
{
  "equipmentUrn": string,
  "nodes": Node[],
  "edges": Edge[]
}
```

**Node structure:**

```typescript
{
  "id": string,              // URN
  "type": string,            // "equipment" | "device" | "property" | "space" | "connectionpoint"
  "label": string,           // Human-readable label
  "rdfClass": string         // RDF class (e.g., "s223:VAVReheat")
}
```

**Edge structure:**

```typescript
{
  "id": string,              // Unique edge ID ("e1", "e2") or auto-generated in buildingmotif.
  "source": string,          // Source node URN
  "target": string,          // Target node URN
  "property": string,        // RDF predicate (e.g., "s223:hasProperty")
  "type": string,            // "rdf:Property" | "owl:SymmetricProperty"
  "isBidirectional": boolean // True for s223:cnx, s223:connected
}
```

**Success criteria:**

- [ ] Endpoint accepts `equipmentUrn` query parameter
- [ ] Returns nodes array with equipment as root
- [ ] Returns edges array with all RDF relationships
- [ ] Node labels resolved (rdfs:label or derived from class)
- [ ] Edge types correctly identify symmetric properties
- [ ] Response handles 20-50 triples without performance issues
- [ ] Returns 404 for invalid/missing equipment URN
- [ ] Returns 422 for malformed URN format

#### AC #3: âœ… Integration tests pass (valid + invalid + performance)

- [ ] Test valid equipment URN returns complete graph
- [ ] Test invalid URN returns 404
- [ ] Test malformed URN returns 422
- [ ] Test performance: 50 triples < 200ms response time
- [ ] Test graph completeness: all template.fill() triples present
- [ ] Test bidirectional edges identified correctly (s223:cnx)

### Frontend UI

#### AC #4: âœ… "Advanced" button added to mappings list

- [ ] Button visible on each mapping row in mappings list
- [ ] Button labeled "Advanced" or "View Graph" with icon
- [ ] Button click triggers modal overlay (does not navigate)
- [ ] Button disabled if mapping has no equipment URN

#### AC #5: âœ… Modal overlay displays React Flow graph

- [ ] Modal opens on "Advanced" button click
- [ ] Modal fetches triples from `GET /api/v1/223p/triples`
- [ ] React Flow renders equipment as root node (center)
- [ ] All nodes and edges from API displayed
- [ ] Pan/zoom controls functional
- [ ] Modal closes and returns to mappings list
- [ ] Loading state shown while fetching triples

#### AC #6: âœ… Graph visualization is readable and styled

**Node styling:**

- Equipment: Blue
- Device: Green
- Property: Orange
- Space: Purple
- ConnectionPoint: Gray

**Edge styling:**

- rdf:Property: Black solid line
- owl:SymmetricProperty: Gray dashed line with bidirectional arrows

**Layout:**

- Radial or hierarchical layout with equipment at center
- Nodes labeled with `node.label`
- Edges labeled with `edge.property` (abbreviated)

**Performance:**

- [ ] No UI lag with 50+ triples
- [ ] Graph layout algorithm completes < 500ms
- [ ] Smooth pan/zoom interactions

---

## Tasks / Subtasks

### Phase 1: Backend - API Changes (Priority 1)

#### Task 1: Enhance GET /api/v1/223p/mappings response (AC #1)

**Estimated:** ~2 hours

- [ ] **1.1**: Update `MappingsResponseDTO` to include URN metadata

  ```python
  # src/dto/mappings_dto.py
  class EquipmentTypeDTO(BaseModel):
      templateId: str
      urn: str

  class DeviceTypeDTO(BaseModel):
      templateId: str
      urn: str

  class PropertyDTO(BaseModel):
      templateId: str
      urn: str

  class PhysicalSpaceDTO(BaseModel):
      templateId: str
      urn: str

  class MappingDTO(BaseModel):
      equipmentType: EquipmentTypeDTO
      deviceType: DeviceTypeDTO
      property: PropertyDTO
      physicalSpace: Optional[PhysicalSpaceDTO] = None
      domainSpaces: Optional[list[PhysicalSpaceDTO]] = None
  ```

- [ ] **1.2**: Update `MappingsController.get_mappings()` to extract URNs

  ```python
  # src/controllers/mappings_controller.py
  async def get_mappings(self, project_id: str) -> MappingsResponseDTO:
      # 1. Query RDF graph for equipment instances
      # 2. For each equipment, extract URNs for equipment/device/property
      # 3. Map to new DTO structure with templateId + urn
      # 4. Return enriched response
      pass
  ```

- [ ] **1.3**: Implement URN extraction helper methods

  ```python
  # src/utils/urn_utils.py
  def extract_equipment_urn(equipment_uri: URIRef) -> str:
      """Extract equipment URN from RDF URI."""
      pass

  def extract_device_urn(device_uri: URIRef) -> str:
      """Extract device URN from RDF URI."""
      pass

  def extract_property_urn(property_uri: URIRef) -> str:
      """Extract property URN from RDF URI."""
      pass
  ```

- [ ] **1.4**: Update all mappings integration tests for new response format

  ```python
  # tests/integration/test_routers/test_mappings.py
  def test_get_mappings_returns_urn_metadata():
      response = client.get("/api/v1/223p/mappings?projectId=test-project")
      assert response.status_code == 200
      data = response.json()

      mapping = data["mappings"]["device,1:analog-input,1"]
      assert "equipmentType" in mapping
      assert mapping["equipmentType"]["templateId"] == "vav-reheat"
      assert mapping["equipmentType"]["urn"].startswith("urn:equipment:")
  ```

#### Task 2: Create GET /api/v1/223p/triples endpoint (AC #2)

**Estimated:** ~4 hours

- [ ] **2.1**: Create `TriplesResponseDTO` for graph structure

  ```python
  # src/dto/triples_dto.py
  class NodeDTO(BaseModel):
      id: str = Field(..., description="URN")
      type: str = Field(..., description="Node type")
      label: str = Field(..., description="Human-readable label")
      rdfClass: str = Field(..., description="RDF class")

  class EdgeDTO(BaseModel):
      id: str = Field(..., description="Unique edge ID")
      source: str = Field(..., description="Source node URN")
      target: str = Field(..., description="Target node URN")
      property: str = Field(..., description="RDF predicate")
      type: str = Field(..., description="RDF property type")
      isBidirectional: bool = Field(..., description="True for symmetric properties")

  class TriplesResponseDTO(BaseModel):
      equipmentUrn: str
      nodes: list[NodeDTO]
      edges: list[EdgeDTO]
  ```

- [ ] **2.2**: Create `TriplesController` with `get_equipment_triples()`

  ```python
  # src/controllers/triples_controller.py
  class TriplesController:
      def __init__(self):
          self.adapter = BuildingMOTIFAdapter.get_instance()

      async def get_equipment_triples(self, equipment_urn: str) -> TriplesResponseDTO:
          """
          Fetch complete RDF graph for equipment as nodes/edges.

          Args:
              equipment_urn: Equipment URN from mappings response

          Returns:
              Graph structure with nodes and edges
          """
          # 1. Validate URN format
          # 2. Query RDF graph for all triples related to equipment
          # 3. Transform to nodes/edges structure
          # 4. Return graph
          pass
  ```

- [ ] **2.2a**: Create OntologyCache service for dynamic property/class detection (âœ… validated)

  ```python
  # src/services/ontology_cache.py
  from rdflib import Graph, URIRef, RDF, RDFS, OWL, Namespace
  from pathlib import Path

  S223 = Namespace("http://data.ashrae.org/standard223#")

  class OntologyCache:
      """
      Cache for ontology lookups to improve performance.

      Precomputes property types and class hierarchies at startup.
      âœ… VALIDATED: Auto-discovers 3 symmetric properties from 223p.ttl
      """

      def __init__(self, ontology_graph: Graph):
          """
          Initialize cache from 223P ontology.

          Args:
              ontology_graph: Loaded 223p.ttl RDF graph
          """
          self.ontology = ontology_graph
          self.property_types: dict[URIRef, str] = {}
          self.inverse_properties: dict[URIRef, URIRef] = {}
          self.class_hierarchy: dict[URIRef, set[URIRef]] = {}
          self._build_property_cache()
          self._build_inverse_cache()

      def _build_property_cache(self):
          """Pre-compute property types from ontology."""
          # 223P uses s223:SymmetricRelation (custom class)
          for prop in self.ontology.subjects(RDF.type, S223.SymmetricRelation):
              self.property_types[prop] = "owl:SymmetricProperty"

          # Also check standard OWL types
          for prop in self.ontology.subjects(RDF.type, OWL.SymmetricProperty):
              self.property_types[prop] = "owl:SymmetricProperty"

          # Transitive, Functional, etc.
          for prop in self.ontology.subjects(RDF.type, OWL.TransitiveProperty):
              self.property_types[prop] = "owl:TransitiveProperty"

          for prop in self.ontology.subjects(RDF.type, OWL.FunctionalProperty):
              self.property_types[prop] = "owl:FunctionalProperty"

          for prop in self.ontology.subjects(RDF.type, OWL.InverseFunctionalProperty):
              self.property_types[prop] = "owl:InverseFunctionalProperty"

          # Object and Datatype properties (fallback)
          for prop in self.ontology.subjects(RDF.type, OWL.ObjectProperty):
              if prop not in self.property_types:
                  self.property_types[prop] = "owl:ObjectProperty"

          for prop in self.ontology.subjects(RDF.type, OWL.DatatypeProperty):
              if prop not in self.property_types:
                  self.property_types[prop] = "owl:DatatypeProperty"

      def _build_inverse_cache(self):
          """Pre-compute inverse property mappings."""
          for s, p, o in self.ontology.triples((None, OWL.inverseOf, None)):
              self.inverse_properties[s] = o
              self.inverse_properties[o] = s

      def get_property_type(self, predicate: URIRef) -> str:
          """Get property type from cache."""
          return self.property_types.get(predicate, "rdf:Property")

      def is_symmetric(self, predicate: URIRef) -> bool:
          """Check if property is symmetric."""
          return self.property_types.get(predicate) == "owl:SymmetricProperty"

      def get_superclasses(self, class_uri: URIRef) -> set[URIRef]:
          """Get all superclasses using transitive closure."""
          if class_uri in self.class_hierarchy:
              return self.class_hierarchy[class_uri]

          superclasses = set()
          for superclass in self.ontology.transitive_objects(class_uri, RDFS.subClassOf):
              superclasses.add(superclass)

          self.class_hierarchy[class_uri] = superclasses
          return superclasses

      @classmethod
      def load_from_file(cls, ontology_path: Path) -> "OntologyCache":
          """
          Load ontology from file and build cache.

          Args:
              ontology_path: Path to 223p.ttl file

          Returns:
              Initialized OntologyCache
          """
          ontology_graph = Graph()
          ontology_graph.parse(ontology_path, format="turtle")
          return cls(ontology_graph)
  ```

  **Reference:** Full validated implementation in `scripts/test_graph_extraction.py`

- [ ] **2.3**: Implement RDF â†’ graph transformation with ontology-based classification (âœ… validated)

  ```python
  # src/services/graph_transformer_service.py
  import hashlib
  from rdflib import Graph, URIRef, RDF, RDFS, OWL, Namespace
  from src.services.ontology_cache import OntologyCache

  S223 = Namespace("http://data.ashrae.org/standard223#")

  class GraphTransformerService:
      """Transform RDF graph to nodes/edges for React Flow using ontology-based classification."""

      def __init__(self, ontology_cache: OntologyCache):
          """
          Initialize with ontology cache for dynamic property/class lookups.

          Args:
              ontology_cache: Precomputed ontology data (property types, class hierarchy)
          """
          self.ontology_cache = ontology_cache

      def transform_to_graph(self, equipment_uri: URIRef, graph: Graph) -> TriplesResponseDTO:
          """
          Transform RDF triples to nodes/edges structure.

          âœ… VALIDATED: Ontology-based implementation from test_graph_extraction.py
          âœ… Auto-discovers 3 symmetric properties (cnx, connected, pairedConnectionPoint)
          âœ… Supports 9 node types and 7 edge types dynamically

          Args:
              equipment_uri: Equipment RDF URI
              graph: RDF graph containing equipment triples

          Returns:
              Graph structure with nodes and edges
          """
          # 1. Extract all unique nodes (subjects + objects)
          nodes_set: set[URIRef] = set()
          for s, p, o in graph:
              if isinstance(s, URIRef):
                  nodes_set.add(s)
              if isinstance(o, URIRef):
                  nodes_set.add(o)

          # 2. Build nodes array with ontology-based classification
          nodes = []
          for uri in nodes_set:
              node = {
                  "id": str(uri),
                  "type": self._classify_node_type(uri, graph),
                  "label": self._extract_node_label(uri, graph),
                  "rdfClass": self._get_rdf_class_qname(uri, graph)
              }
              nodes.append(node)

          # 3. Build edges array with dynamic property type detection
          edges = []
          for s, p, o in graph:
              if not isinstance(o, URIRef):
                  continue

              edge = {
                  "id": self._generate_edge_id(s, p, o),
                  "source": str(s),
                  "target": str(o),
                  "property": self._abbreviate_property(p, graph),
                  "type": self.ontology_cache.get_property_type(p),
                  "isBidirectional": self.ontology_cache.is_symmetric(p)
              }
              edges.append(edge)

          return TriplesResponseDTO(
              equipmentUrn=str(equipment_uri),
              nodes=nodes,
              edges=edges
          )

      def _generate_edge_id(self, source: URIRef, predicate: URIRef, target: URIRef) -> str:
          """Generate unique edge ID using MD5 hash (validated âœ…)."""
          triple_str = f"{source}{predicate}{target}"
          hash_digest = hashlib.md5(triple_str.encode()).hexdigest()[:8]
          return f"e_{hash_digest}"

      def _classify_node_type(self, uri: URIRef, graph: Graph) -> str:
          """
          Classify node using ontology class hierarchy (validated âœ…).

          Uses transitive RDFS reasoning to check superclasses.
          """
          direct_types = set(graph.objects(uri, RDF.type))
          if not direct_types:
              return "connectionpoint"

          # Expand to include all superclasses
          all_types = set()
          for direct_type in direct_types:
              all_types.add(direct_type)
              all_types.update(self.ontology_cache.get_superclasses(direct_type))

          # Priority-based classification
          if S223.Equipment in all_types:
              return "equipment"
          if S223.Property in all_types:
              return "property"
          if S223.ConnectionPoint in all_types:
              return "connectionpoint"
          # ... additional checks (see mini-spec for complete logic)

          return "connectionpoint"

      @staticmethod
      def _abbreviate_property(predicate: URIRef, graph: Graph) -> str:
          """Abbreviate RDF predicate using namespace prefix."""
          try:
              return graph.qname(predicate)
          except Exception:
              # Fallback: manual abbreviation
              pred_str = str(predicate)
              if "#" in pred_str:
                  return pred_str.split("#")[-1]
              return pred_str.split("/")[-1]

      @staticmethod
      def _classify_node_type(uri: URIRef, graph: Graph) -> str:
          """Classify node by rdf:type (see Task 2.4 for full implementation)."""
          pass

      @staticmethod
      def _get_rdf_class_qname(uri: URIRef, graph: Graph) -> str:
          """Get abbreviated RDF class name."""
          rdf_type = graph.value(uri, RDF.type)
          if not rdf_type:
              return "unknown"
          return GraphTransformerService._abbreviate_property(rdf_type, graph)
  ```

  **Reference:** Full validated implementation in `scripts/test_graph_extraction.py`

- [ ] **2.4**: Implement node label resolution (âœ… validated - see mini-spec)

  ```python
  # src/services/graph_transformer_service.py
  @staticmethod
  def _extract_node_label(uri: URIRef, graph: Graph) -> str:
      """
      Extract human-readable label for RDF node.

      3-Tier Fallback Priority (validated via test_graph_extraction.py):
      1. rdfs:label if present (most common - BuildingMOTIF adds these)
      2. Derive from rdf:type class name (e.g., "VAVReheat" â†’ "VAV Reheat")
      3. URI local name (ultimate fallback)

      Args:
          uri: RDF node URI
          graph: RDF graph

      Returns:
          Human-readable label
      """
      # Priority 1: Check rdfs:label (validated - works for equipment/device/property)
      label = graph.value(uri, RDFS.label)
      if label:
          return str(label)

      # Priority 2: Derive from rdf:type class name
      rdf_class = graph.value(uri, RDF.type)
      if rdf_class:
          class_name = str(rdf_class).split("#")[-1].split("/")[-1]
          # Convert PascalCase to spaced Title Case
          import re
          spaced = re.sub(r'([A-Z])', r' \1', class_name).strip()
          return spaced

      # Priority 3: Fallback to URI local name
      return str(uri).split("#")[-1].split("/")[-1]
  ```

- [ ] **2.5**: Add `/api/v1/223p/triples` router

  ```python
  # src/routers/triples.py
  from fastapi import APIRouter, HTTPException, status
  from src.controllers.triples_controller import TriplesController
  from src.dto.triples_dto import TriplesResponseDTO

  router = APIRouter(prefix="/api/v1/223p", tags=["triples"])

  @router.get(
      "/triples",
      response_model=TriplesResponseDTO,
      responses={
          200: {"description": "Equipment graph returned successfully"},
          404: {"description": "Equipment not found"},
          422: {"description": "Invalid URN format"}
      }
  )
  async def get_triples(equipmentUrn: str) -> TriplesResponseDTO:
      """
      Get complete RDF graph for equipment as nodes/edges.

      Returns all triples generated by BuildingMOTIF template.fill()
      for visualization in React Flow.
      """
      controller = TriplesController()
      return await controller.get_equipment_triples(equipmentUrn)
  ```

- [ ] **2.6**: Register triples router in main app

  ```python
  # src/main.py
  from src.routers import triples

  app.include_router(triples.router)
  ```

#### Task 3: Write integration tests (AC #3)

**Estimated:** ~2 hours

- [ ] **3.1**: Create `tests/integration/test_triples.py`

- [ ] **3.2**: Test valid equipment URN returns complete graph

  ```python
  async def test_get_triples_valid_equipment(shared_adapter, test_client):
      """Valid equipment URN returns complete graph structure."""
      # 1. Create equipment mapping
      # 2. GET /api/v1/223p/mappings to extract equipment URN
      # 3. GET /api/v1/223p/triples?equipmentUrn={urn}
      # 4. Assert nodes array present
      # 5. Assert edges array present
      # 6. Assert equipment node is root
      # 7. Assert all template.fill() triples present
      pass
  ```

- [ ] **3.3**: Test invalid URN returns 404

  ```python
  async def test_get_triples_invalid_urn_returns_404(test_client):
      """Invalid equipment URN returns 404."""
      response = test_client.get("/api/v1/223p/triples?equipmentUrn=urn:equipment:invalid")
      assert response.status_code == 404
      assert "Equipment not found" in response.json()["detail"]
  ```

- [ ] **3.4**: Test malformed URN returns 422

  ```python
  async def test_get_triples_malformed_urn_returns_422(test_client):
      """Malformed URN format returns 422."""
      response = test_client.get("/api/v1/223p/triples?equipmentUrn=invalid-format")
      assert response.status_code == 422
      assert "Invalid URN format" in response.json()["detail"]
  ```

- [ ] **3.5**: Test performance with 50 triples

  ```python
  async def test_get_triples_performance(shared_adapter, test_client):
      """Graph retrieval completes in < 200ms for 50 triples."""
      # Create complex equipment with 50+ triples
      # Measure response time
      # Assert response time < 200ms
      pass
  ```

- [ ] **3.6**: Test bidirectional edges identified correctly

  ```python
  async def test_get_triples_bidirectional_edges(shared_adapter, test_client):
      """Symmetric properties marked as bidirectional."""
      # Create equipment with s223:cnx relationship
      # GET /api/v1/223p/triples
      # Find edge with property "s223:cnx"
      # Assert edge.isBidirectional == True
      # Assert edge.type == "owl:SymmetricProperty"
      pass
  ```

---

### Phase 2: Frontend - UI Integration (Priority 2)

#### Task 4: Update TypeScript client and types (AC #1)

**Estimated:** ~1 hour

- [ ] **4.1**: Regenerate TypeScript client from updated OpenAPI spec

  ```bash
  cd apps/designer
  pnpm run generate:api-client
  ```

- [ ] **4.2**: Create TypeScript types for graph structure

  ```typescript
  // apps/designer/src/domains/building-semantics/api/types/triples.ts
  export interface Node {
    id: string; // URN
    type: "equipment" | "device" | "property" | "space" | "connectionpoint";
    label: string;
    rdfClass: string;
  }

  export interface Edge {
    id: string;
    source: string; // Source node URN
    target: string; // Target node URN
    property: string; // RDF predicate
    type: "rdf:Property" | "owl:SymmetricProperty";
    isBidirectional: boolean;
  }

  export interface EquipmentGraph {
    equipmentUrn: string;
    nodes: Node[];
    edges: Edge[];
  }
  ```

- [ ] **4.3**: Update mappings DTO types

  ```typescript
  // apps/designer/src/domains/building-semantics/api/types/mappings.ts
  export interface EquipmentTypeDTO {
    templateId: string;
    urn: string;
  }

  export interface DeviceTypeDTO {
    templateId: string;
    urn: string;
  }

  export interface PropertyDTO {
    templateId: string;
    urn: string;
  }

  export interface MappingDTO {
    equipmentType: EquipmentTypeDTO;
    deviceType: DeviceTypeDTO;
    property: PropertyDTO;
    physicalSpace: PhysicalSpaceDTO | null;
    domainSpaces: PhysicalSpaceDTO[] | null;
  }
  ```

- [ ] **4.4**: Update all mappings UI components for new DTO structure

  - Update `MappingsList` component
  - Update `MappingPopupModal` component
  - Update React Query hooks (`useMappingsQuery`)
  - Fix TypeScript errors

#### Task 5: Create "Advanced" button in mappings list (AC #4)

**Estimated:** ~1 hour

- [ ] **5.1**: Add "Advanced" button to mappings list row

  ```tsx
  // apps/designer/src/domains/building-semantics/components/mappings-list.tsx
  function MappingRow({ pointId, mapping }: MappingRowProps) {
    const [showTripleInspector, setShowTripleInspector] = useState(false);

    return (
      <div className="mapping-row">
        <div className="mapping-info">{/* Existing mapping display */}</div>
        <div className="mapping-actions">
          <Button
            variant="outline"
            size="sm"
            onClick={() => setShowTripleInspector(true)}
            disabled={!mapping.equipmentType.urn}
          >
            <FileTextIcon className="mr-2 h-4 w-4" />
            Advanced
          </Button>
        </div>

        {showTripleInspector && (
          <TripleInspectorModal
            equipmentUrn={mapping.equipmentType.urn}
            onClose={() => setShowTripleInspector(false)}
          />
        )}
      </div>
    );
  }
  ```

#### Task 6: Create `<TripleInspectorModal>` component (AC #5, #6)

**Estimated:** ~4 hours

- [ ] **6.1**: Create modal component with React Flow integration

  ```tsx
  // apps/designer/src/domains/building-semantics/components/triple-inspector-modal.tsx
  import ReactFlow, {
    Node as FlowNode,
    Edge as FlowEdge,
    Background,
    Controls,
    MiniMap,
  } from "reactflow";
  import "reactflow/dist/style.css";

  interface TripleInspectorModalProps {
    equipmentUrn: string;
    onClose: () => void;
  }

  export function TripleInspectorModal({
    equipmentUrn,
    onClose,
  }: TripleInspectorModalProps) {
    const { data, isLoading, error } = useEquipmentGraphQuery(equipmentUrn);

    const { nodes, edges } = useMemo(() => {
      if (!data) return { nodes: [], edges: [] };
      return transformToReactFlowGraph(data);
    }, [data]);

    return (
      <Dialog open={true} onOpenChange={onClose}>
        <DialogContent className="max-w-6xl h-[80vh]">
          <DialogHeader>
            <DialogTitle>Equipment Graph - {equipmentUrn}</DialogTitle>
          </DialogHeader>

          <div className="h-full w-full">
            {isLoading && <LoadingSpinner />}
            {error && <ErrorMessage error={error} />}
            {data && (
              <ReactFlow
                nodes={nodes}
                edges={edges}
                fitView
                nodesDraggable={true}
                nodesConnectable={false}
                elementsSelectable={true}
              >
                <Background />
                <Controls />
                <MiniMap />
              </ReactFlow>
            )}
          </div>
        </DialogContent>
      </Dialog>
    );
  }
  ```

- [ ] **6.2**: Create React Query hook for triples endpoint

  ```typescript
  // apps/designer/src/domains/building-semantics/api/queries/use-equipment-graph-query.ts
  import { useQuery } from "@tanstack/react-query";
  import { apiClient } from "../client";
  import type { EquipmentGraph } from "../types/triples";

  export function useEquipmentGraphQuery(equipmentUrn: string) {
    return useQuery({
      queryKey: ["equipment-graph", equipmentUrn],
      queryFn: () => apiClient.getTriples({ equipmentUrn }),
      enabled: !!equipmentUrn,
      staleTime: 5 * 60 * 1000, // 5 minutes
    });
  }
  ```

- [ ] **6.3**: Implement graph transformation to React Flow format

  ```typescript
  // apps/designer/src/domains/building-semantics/utils/graph-transformer.ts
  import type { Node as FlowNode, Edge as FlowEdge } from "reactflow";
  import type { EquipmentGraph, Node, Edge } from "../api/types/triples";
  import dagre from "dagre";

  export function transformToReactFlowGraph(graph: EquipmentGraph): {
    nodes: FlowNode[];
    edges: FlowEdge[];
  } {
    // Transform nodes
    const nodes: FlowNode[] = graph.nodes.map((node) => ({
      id: node.id,
      type: "custom",
      data: {
        label: node.label,
        rdfClass: node.rdfClass,
        nodeType: node.type,
      },
      position: { x: 0, y: 0 }, // Will be set by layout
      style: getNodeStyle(node.type),
    }));

    // Transform edges
    const edges: FlowEdge[] = graph.edges.map((edge) => ({
      id: edge.id,
      source: edge.source,
      target: edge.target,
      label: abbreviateProperty(edge.property),
      type: edge.isBidirectional ? "bidirectional" : "default",
      style: getEdgeStyle(edge.type),
      markerEnd: {
        type: "arrowclosed",
      },
      ...(edge.isBidirectional && {
        markerStart: {
          type: "arrowclosed",
        },
      }),
    }));

    // Apply layout
    return applyDagreLayout(nodes, edges, graph.equipmentUrn);
  }

  function getNodeStyle(nodeType: string) {
    const colors = {
      equipment: "#3b82f6", // Blue
      device: "#22c55e", // Green
      property: "#f97316", // Orange
      space: "#a855f7", // Purple
      connectionpoint: "#6b7280", // Gray
    };

    return {
      background: colors[nodeType] || "#6b7280",
      color: "#ffffff",
      border: "2px solid #000",
      borderRadius: "8px",
      padding: "10px",
    };
  }

  function getEdgeStyle(edgeType: string) {
    return {
      stroke: edgeType === "owl:SymmetricProperty" ? "#6b7280" : "#000",
      strokeDasharray: edgeType === "owl:SymmetricProperty" ? "5,5" : undefined,
      strokeWidth: 2,
    };
  }

  function abbreviateProperty(property: string): string {
    // Abbreviate common ASHRAE 223P properties
    const abbreviations: Record<string, string> = {
      "s223:hasProperty": "hasProperty",
      "s223:contains": "contains",
      "s223:cnx": "cnx",
      "s223:connected": "connected",
      "s223:locatedIn": "locatedIn",
      "bacnet:device-identifier": "device-id",
      "bacnet:object-identifier": "object-id",
    };

    return abbreviations[property] || property.split(":")[1] || property;
  }

  function applyDagreLayout(
    nodes: FlowNode[],
    edges: FlowEdge[],
    rootNodeId: string,
  ): { nodes: FlowNode[]; edges: FlowEdge[] } {
    const dagreGraph = new dagre.graphlib.Graph();
    dagreGraph.setDefaultEdgeLabel(() => ({}));
    dagreGraph.setGraph({ rankdir: "TB" }); // Top to bottom

    nodes.forEach((node) => {
      dagreGraph.setNode(node.id, { width: 150, height: 50 });
    });

    edges.forEach((edge) => {
      dagreGraph.setEdge(edge.source, edge.target);
    });

    dagre.layout(dagreGraph);

    return {
      nodes: nodes.map((node) => {
        const position = dagreGraph.node(node.id);
        return {
          ...node,
          position: {
            x: position.x - 75, // Center node
            y: position.y - 25,
          },
        };
      }),
      edges,
    };
  }
  ```

- [ ] **6.4**: Create custom React Flow node component

  ```tsx
  // apps/designer/src/domains/building-semantics/components/custom-graph-node.tsx
  import { memo } from "react";
  import { Handle, Position } from "reactflow";

  interface CustomNodeProps {
    data: {
      label: string;
      rdfClass: string;
      nodeType: string;
    };
  }

  export const CustomGraphNode = memo(({ data }: CustomNodeProps) => {
    return (
      <div className="custom-node">
        <Handle type="target" position={Position.Top} />

        <div className="node-content">
          <div className="node-label">{data.label}</div>
          <div className="node-class text-xs opacity-70">{data.rdfClass}</div>
        </div>

        <Handle type="source" position={Position.Bottom} />
      </div>
    );
  });
  ```

- [ ] **6.5**: Install React Flow dependencies

  ```bash
  cd apps/designer
  pnpm add reactflow dagre
  pnpm add -D @types/dagre
  ```

- [ ] **6.6**: Add graph visualization styles

  ```css
  /* apps/designer/src/domains/building-semantics/components/triple-inspector-modal.css */
  .react-flow__node-custom {
    font-family: inherit;
  }

  .custom-node {
    padding: 10px;
    border-radius: 8px;
    border: 2px solid #000;
    background: var(--node-bg);
    color: white;
    min-width: 150px;
  }

  .node-label {
    font-weight: 600;
    font-size: 14px;
  }

  .node-class {
    font-size: 11px;
    margin-top: 4px;
    opacity: 0.7;
  }
  ```

---

### Phase 3: Testing & Refinement (Priority 3)

#### Task 7: Manual testing and refinement

**Estimated:** ~2 hours

- [ ] **7.1**: Test with real BuildingMOTIF data

  - Create equipment mapping
  - Click "Advanced" button
  - Verify modal opens with graph
  - Verify all nodes and edges displayed
  - Verify graph layout is readable

- [ ] **7.2**: Test graph interactions

  - Pan graph
  - Zoom in/out
  - Drag nodes
  - Hover over nodes/edges for tooltips
  - Close modal

- [ ] **7.3**: Test performance with 50+ triples

  - Create complex equipment (VAV with multiple devices)
  - Verify graph loads in < 500ms
  - Verify no UI lag during interactions

- [ ] **7.4**: Test error scenarios

  - Invalid equipment URN
  - Network error
  - Empty graph
  - Verify error messages displayed correctly

- [ ] **7.5**: Accessibility testing

  - Keyboard navigation
  - Screen reader compatibility
  - Focus management (modal trap)
  - Color contrast

---

## Dev Notes

### Architecture Alignment

**MVC Pattern (Backend):**

```
src/routers/triples.py              # HTTP layer (request/response)
src/controllers/triples_controller.py  # Business logic (graph retrieval)
src/services/graph_transformer_service.py  # RDF â†’ nodes/edges transformation
src/adapters/buildingmotif_adapter.py   # BuildingMOTIF SDK operations
src/utils/urn_utils.py               # URN extraction helpers
```

**Graph Transformation Flow:**

```
GET /api/v1/223p/triples?equipmentUrn={urn}
    â†“
TriplesController.get_equipment_triples(urn)
    â†“
1. Validate URN format
2. Query RDF graph for equipment triples
3. GraphTransformerService.transform_to_graph()
4. Extract nodes (subjects + objects)
5. Extract edges (predicates)
6. Classify nodes by type
7. Identify bidirectional edges
8. Extract labels (rdfs:label or fallback)
9. Return TriplesResponseDTO
```

**Frontend Component Hierarchy:**

```
<MappingsList>
  â””â”€â”€ <MappingRow>
      â”œâ”€â”€ "Advanced" button
      â””â”€â”€ <TripleInspectorModal>
          â””â”€â”€ <ReactFlow>
              â”œâ”€â”€ <CustomGraphNode /> (equipment)
              â”œâ”€â”€ <CustomGraphNode /> (device)
              â”œâ”€â”€ <CustomGraphNode /> (property)
              â””â”€â”€ <CustomGraphNode /> (space)
```

### Learnings from Previous Story (Story 2.10)

**From Story 2-10-implement-shacl-validation.md:**

- **Architectural Pattern**: Router â†’ Controller â†’ Service â†’ Adapter

  - Use same pattern for TriplesController
  - Controllers handle orchestration
  - Services contain pure transformation logic
  - Adapters interface with BuildingMOTIF

- **BuildingMOTIF Integration**: Reuse `BuildingMOTIFAdapter.get_instance()` singleton

  - No need to recreate adapter
  - Use existing session-scoped fixtures for tests
  - Pattern established in `tests/integration/conftest.py`

- **Type Hints**: Complete Python type hints (PEP 484)

  - Use specific return types for `transform_to_graph()`
  - Example: `TriplesResponseDTO` with explicit node/edge types

- **Error Handling**: Resilient with logging

  - Return 404 for missing equipment
  - Return 422 for malformed URN
  - Log errors with context

- **Testing Setup**: Reuse session-scoped fixtures

  - Use `shared_adapter` fixture for integration tests
  - Unique project_id per test for isolation
  - Pattern: Create mapping â†’ Get URN â†’ Get triples

- **API Response Format**: Breaking changes acceptable in development

  - Story 2.10 changed status code from 200 to 201
  - This story changes mappings response structure
  - Both acceptable - update tests and regenerate TypeScript client

[Source: stories/2-10-implement-shacl-validation.md#Dev-Agent-Record]

### Implementation Validation (RDFLib Capabilities)

**âœ… VALIDATED:** All required fields are extractable from RDFLib Graph API

**Test Script:** `apps/building-semantics-api-app/scripts/test_graph_extraction.py`

**Confirmed RDFLib Methods:**

- âœ… Node extraction: `for s, p, o in graph` (subjects + objects)
- âœ… Node type: `graph.value(uri, RDF.type)` + classification logic
- âœ… Node label: `graph.value(uri, RDFS.label)` with 3-tier fallback
- âœ… Node RDF class: `graph.value(uri, RDF.type)` + namespace abbreviation
- âœ… Edge extraction: `for s, p, o in graph` (all triples)
- âœ… Edge property: `graph.qname(predicate)` for abbreviation (e.g., "s223:contains")
- âœ… Edge type: Check if predicate in SYMMETRIC_PROPERTIES set
- âœ… Edge bidirectional: `predicate in {S223.cnx, S223.connected}`

**Node Label Resolution - Validated 3-Tier Fallback:**

```python
def extract_node_label(uri: URIRef, graph: Graph) -> str:
    # Priority 1: rdfs:label if present (most common)
    label = graph.value(uri, RDFS.label)
    if label:
        return str(label)

    # Priority 2: Derive from rdf:type class name
    rdf_type = graph.value(uri, RDF.type)
    if rdf_type:
        return str(rdf_type).split("#")[-1]

    # Priority 3: Fallback to URI local name
    return str(uri).split("#")[-1]
```

**Tested Results:**

- Equipment: "VAV Reheat Box 101" (from rdfs:label) âœ…
- Device: "Zone Temperature Sensor" (from rdfs:label) âœ…
- Property: "Zone Air Temperature" (from rdfs:label) âœ…
- Unit: "DEG_F" (from URI fallback) âœ…

**Edge ID Generation:**

```python
def generate_edge_id(source: URIRef, predicate: URIRef, target: URIRef) -> str:
    """Generate unique edge ID using MD5 hash."""
    triple_str = f"{source}{predicate}{target}"
    hash_digest = hashlib.md5(triple_str.encode()).hexdigest()[:8]
    return f"e_{hash_digest}"
```

**Rationale:**

- BuildingMOTIF does not auto-generate edge IDs
- Hash ensures uniqueness and stability across API calls
- 8-character hash provides sufficient collision resistance

**Validation Results:**

- Total triples: 19 (sample VAV equipment)
- Nodes extracted: 13
- Edges extracted: 12
- All validation checks passed âœ…

**See full validation details:** `mini-specs/2-11-triple-inspector-architecture.md#implementation-validation`

### ASHRAE 223P Connection Properties Reference

All connection predicates become `edge.property` values:

| Property                | Type                  | Bidirectional | Purpose                          |
| ----------------------- | --------------------- | ------------- | -------------------------------- |
| s223:hasProperty        | rdf:Property          | No            | Equipment â†’ Property             |
| s223:hasConnectionPoint | rdf:Property          | No            | Equipment â†’ ConnectionPoint      |
| s223:cnx                | owl:SymmetricProperty | Yes           | Low-level connection             |
| s223:connected          | owl:SymmetricProperty | Yes           | High-level connection            |
| s223:connectedTo        | rdf:Property          | No            | Source â†’ Target (flow direction) |
| s223:connectedFrom      | rdf:Property          | No            | Target â†’ Source (inverse)        |
| s223:connectedThrough   | rdf:Property          | No            | Equipment â†’ Connection           |
| s223:contains           | rdf:Property          | No            | Equipment â†’ Device/Equipment     |
| s223:locatedIn          | rdf:Property          | No            | Equipment â†’ Space                |
| s223:hasDomain          | rdf:Property          | No            | Equipment â†’ DomainSpace          |

### Performance Considerations

**Backend:**

- Graph queries optimized for single equipment (not all mappings)
- Expected triple count: 20-50 per equipment
- Target response time: < 200ms for 50 triples

**Frontend:**

- React Flow handles 50+ nodes efficiently
- Dagre layout algorithm: < 500ms for typical graphs
- Memoization prevents unnecessary re-renders
- Virtual scrolling not needed (manageable graph size)

### Future Enhancements (Out of Scope)

1. **Copy/Download Functionality:**

   - Copy URN to clipboard
   - Download graph as Turtle format
   - Download graph as JSON-LD format

2. **Advanced Filtering:**

   - Show/hide by node type
   - Show/hide by edge property type
   - Search for specific URNs or classes

3. **Graph Interactions:**

   - Click node to highlight connected edges
   - Expand/collapse subgraphs
   - Alternative layouts (force-directed, circular)

4. **Triple Table View:**
   - Alternative view: subject-predicate-object table
   - Toggle between graph and table

---

## Validation Status âœ…

### Test Script Validation Complete

**Location:** `apps/building-semantics-api-app/scripts/test_graph_extraction.py`

**Validated Implementation Approach:**

- âœ… **Ontology-based classification** (not hardcoded)
- âœ… **3 symmetric properties auto-discovered**: `cnx`, `connected`, `pairedConnectionPoint`
- âœ… **9 node types supported**: equipment, device, property, space, zone, connectionpoint, connection, junction, function, externalreference
- âœ… **7 edge types supported**: rdf:Property, owl:ObjectProperty, owl:DatatypeProperty, owl:SymmetricProperty, owl:TransitiveProperty, owl:FunctionalProperty, owl:InverseFunctionalProperty

**Test Results:**

```
================================================================================
âœ… ALL VALIDATION CHECKS PASSED

ðŸ“Š ONTOLOGY-BASED CLASSIFICATION WORKING:
   - 3 property types discovered from 223p.ttl
   - 3 symmetric properties auto-detected
   - 4 node types classified (equipment, property, connectionpoint, externalreference)
   - 2 edge types identified (rdf:Property, owl:SymmetricProperty)
   - Edge s223:cnx correctly marked as bidirectional âœ…
================================================================================
```

**Key Architectural Decisions Validated:**

1. âœ… Edge ID generation: MD5 hash of `source+predicate+target`
2. âœ… Node label resolution: 3-tier fallback (rdfs:label â†’ class name â†’ URI)
3. âœ… Symmetric property detection: Query 223p.ttl for `s223:SymmetricRelation`
4. âœ… Node classification: Use RDFS class hierarchy with transitive reasoning
5. âœ… Performance optimization: OntologyCache precomputes at startup

**Implementation Benefits:**

- ðŸŽ¯ **Future-proof**: Works with any 223P ontology version
- ðŸŽ¯ **Complete**: Discovers ALL properties/classes from ontology
- ðŸŽ¯ **Maintainable**: No hardcoded lists to update
- ðŸŽ¯ **Performant**: One-time cache build at startup

---

### References

**Mini-Spec:**

- [Triple Inspector Architecture](../mini-specs/2-11-triple-inspector-architecture.md) - Complete architecture specification with all decisions resolved

**Epic Documentation:**

- [Epic 2 Phase Breakdown](../epic2/epic-2-phase-breakdown.md#story-211) - Story 2.11 requirements
- [Story 2.8](./2-8-implement-mappings-endpoints.md) - Mappings controller patterns
- [Story 2.10](./2-10-implement-shacl-validation.md) - SHACL validation and error handling patterns

**Architecture:**

- [Architecture](../../architecture.md) - MVC pattern, testing strategy
- [Coding Standards](../../coding-standards.md) - Python/TypeScript style guide

**BuildingMOTIF:**

- [BuildingMOTIF Docs](https://buildingmotif.readthedocs.io/) - RDF graph querying
- [ASHRAE 223P](https://docs.open223.info/) - Semantic equipment model

**React Flow:**

- [React Flow Docs](https://reactflow.dev/) - Graph visualization library
- [Dagre Layout](https://github.com/dagrejs/dagre) - Hierarchical graph layout

---

## Dev Agent Record

### Context Reference

<!-- Path(s) to story context XML will be added here by context workflow -->

### Agent Model Used

{{agent_model_name_version}}

### Debug Log References

### Completion Notes List

### File List
